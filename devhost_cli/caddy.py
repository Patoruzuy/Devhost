"""Caddy configuration generation and management"""

import os
import shutil
import subprocess
from pathlib import Path
from typing import Any

from .config import Config
from .platform import IS_WINDOWS
from .executable_validation import validate_executable
from .subprocess_timeouts import get_timeout, TIMEOUT_NONE


def render_caddyfile(routes: dict[str, Any]) -> str:
    """Generate Caddyfile content from routes configuration"""
    domain = Config().get_domain()

    # Read template file and substitute domain
    script_dir = Path(__file__).parent.parent.resolve()
    template_path = script_dir / "caddy" / "Caddyfile.template"

    if template_path.exists():
        template_content = template_path.read_text(encoding="utf-8")
        # Replace *.localhost with *.{domain}
        template_content = template_content.replace("*.localhost", f"*.{domain}")
        lines = ["# Autogenerated Caddyfile for Devhost", template_content]
    else:
        # Fallback if template doesn't exist
        lines = [
            "# Autogenerated Caddyfile for Devhost",
            f"http://*.{domain} {{",
            "    reverse_proxy localhost:7777",
            "}",
            "",
        ]

    # Add direct mappings for each route
    if routes:
        lines.append("# Direct mappings per service")
        for name in sorted(routes.keys()):
            value = routes[name]
            value_str = str(value)

            # Determine scheme
            if value_str.startswith("https://"):
                site = f"{name}.{domain}"
                target = value_str
                lines.append(f"{site} {{")
                lines.append(f"    reverse_proxy {target}")
                lines.append("    tls internal")
                lines.append("}")
            elif value_str.startswith("http://"):
                site = f"http://{name}.{domain}"
                target = value_str
                lines.append(f"{site} {{")
                lines.append(f"    reverse_proxy {target}")
                lines.append("}")
            elif ":" in value_str:
                # host:port format
                site = f"http://{name}.{domain}"
                target = value_str
                lines.append(f"{site} {{")
                lines.append(f"    reverse_proxy {target}")
                lines.append("}")
            else:
                # Just port number
                site = f"http://{name}.{domain}"
                target = f"127.0.0.1:{value_str}"
                lines.append(f"{site} {{")
                lines.append(f"    reverse_proxy {target}")
                lines.append("}")
            lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def generate_caddyfile(routes: dict[str, Any] | None = None) -> None:
    """Generate Caddyfile and sync to system locations"""
    if routes is None:
        routes = Config().load()

    content = render_caddyfile(routes)

    # Always write to user config directory (works for pip install and source install)
    user_caddy = Path.home() / ".config" / "caddy" / "Caddyfile"
    user_caddy.parent.mkdir(parents=True, exist_ok=True)
    user_caddy.write_text(content, encoding="utf-8")

    # Also write to project caddy/ directory if it exists (for source installs)
    script_dir = Path(__file__).parent.parent.resolve()
    project_caddy_dir = script_dir / "caddy"
    if project_caddy_dir.exists():
        caddyfile_path = project_caddy_dir / "Caddyfile"
        caddyfile_path.write_text(content, encoding="utf-8")

    # Sync to system Caddy config (non-Windows)
    if not IS_WINDOWS:
        system_caddy = Path("/etc/caddy/Caddyfile")
        if system_caddy.exists():
            # Validate sudo executable
            sudo_path = shutil.which("sudo")
            if sudo_path:
                is_valid, error = validate_executable(sudo_path)
                if is_valid:
                    subprocess.run(
                        [sudo_path, "cp", str(user_caddy), str(system_caddy)],
                        check=False,
                        timeout=get_timeout("sudo"),
                    )
                # If invalid, silently skip (user config still works)
        
        # Reload systemd service
        systemctl_path = shutil.which("systemctl")
        if systemctl_path and sudo_path:
            is_valid_systemctl, _ = validate_executable(systemctl_path)
            is_valid_sudo, _ = validate_executable(sudo_path)
            if is_valid_systemctl and is_valid_sudo:
                subprocess.run(
                    [sudo_path, systemctl_path, "reload", "caddy"],
                    check=False,
                    timeout=get_timeout("systemctl"),
                )


def print_caddyfile(routes: dict[str, Any] | None = None) -> None:
    """Print generated Caddyfile to stdout"""
    if routes is None:
        routes = Config().load()
    print(render_caddyfile(routes))


def edit_config() -> None:
    """Open devhost.json in text editor"""
    config = Config()
    config_file = config.config_file
    if not config_file.exists():
        config_file.parent.mkdir(parents=True, exist_ok=True)
        config_file.write_text("{}", encoding="utf-8")

    editor = os.environ.get("EDITOR")
    if not editor:
        if IS_WINDOWS:
            editor = "notepad.exe"
        elif shutil.which("nano"):
            editor = "nano"
        else:
            editor = "vi"
    
    # Validate editor executable
    is_valid, error = validate_executable(editor, check_writability=False)
    if not is_valid:
        print(f"Warning: Editor validation failed: {error}")
        print("Attempting to open anyway...")
    
    subprocess.run([editor, str(config_file)], check=False, timeout=TIMEOUT_NONE)
