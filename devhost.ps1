param(
  [Parameter(ValueFromRemainingArguments = $true)]
  [string[]]$Args
)

$Root = Split-Path -Parent $MyInvocation.MyCommand.Path
$Config = Join-Path $Root 'devhost.json'
$CaddyFile = Join-Path $Root 'caddy\Caddyfile'
$RouterDir = Join-Path $Root 'router'
$PidFile = Join-Path $Root '.devhost\router.pid'
$LogFile = Join-Path $env:TEMP 'devhost-router.log'

function Show-Usage {
  @'
Usage: devhost <command> [args]

Commands:
  add <name> <port|host:port>       Add a mapping
  add <name> --http <port|host:port>   Force http for dev URL
  add <name> --https <port|host:port>  Force https for dev URL
  remove <name>                    Remove a mapping
  list                             List mappings
  url [name]                       Print URL
  open [name]                      Open URL in default browser
  validate                         Quick config/router/DNS checks
  export caddy                     Print generated Caddyfile
  edit                             Open devhost.json in editor
  resolve <name>                   Show DNS resolution and port reachability
  doctor                           Deeper diagnostics
  info                             Show this help
  start|stop|status                Manage router process
  install --windows                Run Windows installer
'@ | Write-Host
}

function Get-Config {
  if (-not (Test-Path $Config)) {
    '{}' | Set-Content -Encoding utf8 $Config
  }
  try {
    $raw = Get-Content $Config -Raw
    if (-not $raw.Trim()) { $raw = '{}' }
    return $raw | ConvertFrom-Json
  } catch {
    return @{}
  }
}

function Save-Config($obj) {
  $json = $obj | ConvertTo-Json -Depth 20
  $json | Set-Content -Encoding utf8 $Config
}

function Get-FirstName {
  $cfg = Get-Config
  $keys = $cfg.PSObject.Properties.Name | Sort-Object
  if ($keys.Count -gt 0) { return $keys[0] }
  return $null
}

function Convert-Target($value) {
  if ($null -eq $value) { return $null }
  $scheme = 'http'
  $targetHost = '127.0.0.1'
  $port = $null
  $rest = $value.ToString()

  if ($rest -match '^https?://') {
    $scheme = $rest.Split('://')[0]
    $rest = $rest.Substring($scheme.Length + 3)
    $rest = $rest.Split('/')[0]
  }

  if ($rest -match ':') {
    $parts = $rest.Split(':',2)
    $targetHost = $parts[0]
    $port = $parts[1]
  } else {
    $port = $rest
  }

  if (-not $targetHost -or -not $port) { return $null }
  return @{ scheme=$scheme; host=$targetHost; port=$port }
}

function New-CaddyFile($cfg) {
  $lines = @(
    '# Autogenerated Caddyfile',
    '*.localhost {',
    '    reverse_proxy localhost:5555',
    '    tls internal',
    '}',
    ''
  )

  if ($cfg.PSObject.Properties.Count -gt 0) {
    $lines += '# Direct mappings'
    foreach ($p in $cfg.PSObject.Properties) {
      $name = $p.Name
      $value = $p.Value.ToString()
      $target = $value
      if ($value -notmatch '^https?://') {
        if ($value -notmatch ':') {
          $target = "localhost:$value"
        }
      }
      if ($value -match '^http://') {
        $lines += "http://$name.localhost {"
      } else {
        $lines += "$name.localhost {"
      }
      $lines += "    reverse_proxy $target"
      if ($value -notmatch '^http://') {
        $lines += '    tls internal'
      }
      $lines += '}'
      $lines += ''
    }
  }

  $lines -join "`n" | Set-Content -Encoding utf8 $CaddyFile
}

function Add-Mapping($argsList) {
  if ($argsList.Count -lt 2) { Show-Usage; return }
  $name = $argsList[0]
  $scheme = $null
  $target = $null
  for ($i=1; $i -lt $argsList.Count; $i++) {
    switch ($argsList[$i]) {
      '--http' { $scheme = 'http' }
      '--https' { $scheme = 'https' }
      default { $target = $argsList[$i] }
    }
  }
  if (-not $target) { Write-Host 'Port must be a number or host:port'; return }
  if ($scheme) {
    if ($target -match '^https?://') { Write-Host 'Target already includes a scheme'; return }
    $target = "${scheme}://$target"
  }
  $cfg = Get-Config
  $cfg | Add-Member -NotePropertyName $name -NotePropertyValue $target -Force
  Save-Config $cfg
  New-CaddyFile $cfg
  Write-Host "[+] Mapped $name.localhost to $target"
}

function Remove-Mapping($name) {
  if (-not $name) { Show-Usage; return }
  $cfg = Get-Config
  $cfg.PSObject.Properties.Remove($name) | Out-Null
  Save-Config $cfg
  New-CaddyFile $cfg
  Write-Host "[-] Removed mapping for $name.localhost"
}

function Get-Mappings {
  $cfg = Get-Config
  $cfg | ConvertTo-Json -Depth 10
}

function Get-UrlForName($name) {
  if (-not $name) { $name = Get-FirstName }
  if (-not $name) { Write-Host 'No mappings found.'; return $null }
  $cfg = Get-Config
  $value = $cfg.$name
  if (-not $value) { Write-Host "No mapping found for $name.localhost"; return $null }
  if ($value -match '^https://') { $scheme = 'https' } elseif ($value -match '^http://') { $scheme = 'http' } else { $scheme = 'https' }
  return "${scheme}://$name.localhost"
}

function Open-Url($name) {
  $url = Get-UrlForName $name
  if ($url) { Start-Process $url }
}

function Validate {
  Write-Host "Config: $Config"
  try { $null = Get-Config; Write-Host 'Config JSON: OK' } catch { Write-Host 'Config JSON: invalid' }

  try {
    $resp = Invoke-WebRequest -Uri 'http://127.0.0.1:5555/health' -UseBasicParsing -TimeoutSec 2
    if ($resp.StatusCode -eq 200) { Write-Host 'Router: OK' } else { Write-Host 'Router: not responding' }
  } catch { Write-Host 'Router: not responding' }
}

function Resolve-Name($name) {
  if (-not $name) { Show-Usage; return }
  $cfg = Get-Config
  $value = $cfg.$name
  if (-not $value) { Write-Host "No mapping found for $name.localhost"; return }
  $norm = Convert-Target $value
  Write-Host "$name.localhost -> $($norm.scheme)://$($norm.host):$($norm.port)"

  try {
    $dns = Resolve-DnsName "$name.localhost" -ErrorAction Stop | Select-Object -First 1
    Write-Host "DNS: $($dns.IPAddress)"
  } catch {
    Write-Host 'DNS: unresolved'
  }

  $tnc = Test-NetConnection -ComputerName $norm.host -Port $norm.port -WarningAction SilentlyContinue
  if ($tnc.TcpTestSucceeded) { Write-Host "Port: $($norm.host):$($norm.port) is open" } else { Write-Host "Port: $($norm.host):$($norm.port) is not reachable" }
}

function Doctor {
  Write-Host "Devhost doctor"
  Validate
  if (Get-Command caddy -ErrorAction SilentlyContinue) {
    $p = Get-Process caddy -ErrorAction SilentlyContinue
    if ($p) { Write-Host 'Caddy: running' } else { Write-Host 'Caddy: installed but not running' }
  } else {
    Write-Host 'Caddy: not found'
  }
}

function Start-Router {
  if (-not (Test-Path $RouterDir)) { Write-Host 'Router directory not found'; return }
  $venvPy = Join-Path $RouterDir 'venv\Scripts\python.exe'
  if (-not (Test-Path $venvPy)) { Write-Host 'Venv python not found. Run scripts\setup-windows.ps1'; return }
  New-Item -ItemType Directory -Force (Split-Path $PidFile) | Out-Null
  $uvicornArgs = '-m uvicorn app:app --host 127.0.0.1 --port 5555'
  $proc = Start-Process -FilePath $venvPy -ArgumentList $uvicornArgs -WorkingDirectory $RouterDir -PassThru -RedirectStandardOutput $LogFile -RedirectStandardError $LogFile
  $proc.Id | Set-Content $PidFile
  Write-Host "Router started (pid $($proc.Id)), logs: $LogFile"
}

function Stop-Router {
  if (-not (Test-Path $PidFile)) { Write-Host 'Router not running'; return }
  $pidValue = Get-Content $PidFile
  if ($pidValue) {
    try { Stop-Process -Id $pidValue -Force -ErrorAction Stop; Write-Host "Stopped $pidValue" } catch { Write-Host "Failed to stop $pidValue" }
  }
  Remove-Item $PidFile -ErrorAction SilentlyContinue
}

function Get-RouterStatus($json) {
  $running = $false
  $pidValue = $null
  if (Test-Path $PidFile) {
    $pidValue = Get-Content $PidFile
    if ($pidValue) {
      $p = Get-Process -Id $pidValue -ErrorAction SilentlyContinue
      if ($p) { $running = $true }
    }
  }
  $health = 'unknown'
  try {
    $null = Invoke-WebRequest -Uri 'http://127.0.0.1:5555/health' -UseBasicParsing -TimeoutSec 2
    $health = 'ok'
  } catch {
    $health = 'not_responding'
  }
  if ($json) {
    $obj = @{ running=$running; pid=($pidValue -as [int]); health=$health }
    $obj | ConvertTo-Json -Compress
  } else {
    if ($running) { Write-Host "Router running (pid $pidValue)" } else { Write-Host 'Router not running' }
    Write-Host "Health check: $health"
  }
}

function Edit-Config {
  $editor = $env:EDITOR
  if (-not $editor) { $editor = 'notepad.exe' }
  Start-Process $editor $Config
}

switch ($Args[0]) {
  'add' { Add-Mapping $Args[1..($Args.Count-1)] }
  'remove' { Remove-Mapping $Args[1] }
  'list' { Get-Mappings }
  'url' { $u = Get-UrlForName $Args[1]; if ($u) { Write-Host $u } }
  'open' { Open-Url $Args[1] }
  'validate' { Validate }
  'export' { if ($Args[1] -eq 'caddy') { Get-Content $CaddyFile } else { Show-Usage } }
  'edit' { Edit-Config }
  'resolve' { Resolve-Name $Args[1] }
  'doctor' { Doctor }
  'info' { Show-Usage }
  'start' { Start-Router }
  'stop' { Stop-Router }
  'status' { $json = $false; if ($Args[1] -eq '--json') { $json = $true }; Get-RouterStatus $json }
  'install' { if ($Args[1] -eq '--windows') { & "$Root\scripts\setup-windows.ps1" } else { Show-Usage } }
  default { Show-Usage }
}
