#!/usr/bin/env bash

CONFIG="devhost.json"
CADDYFILE="caddy/Caddyfile"

load_json() {
    if [[ ! -f $CONFIG ]]; then
        echo "{}" > $CONFIG
    fi
    cat "$CONFIG"
}

save_json() {
    echo "$1" > "$CONFIG"
}

generate_caddyfile() {
    # generate project-local Caddyfile and a user-level Caddyfile if present
    echo "# Autogenerated Caddyfile" > "$CADDYFILE"
    echo "*.localhost {" >> "$CADDYFILE"
    echo "    reverse_proxy localhost:5555" >> "$CADDYFILE"
    echo "    tls internal" >> "$CADDYFILE"
    echo "}" >> "$CADDYFILE"

    # Append explicit mappings from devhost.json
    json=$(load_json)
    if command -v jq &> /dev/null; then
        mapcount=$(echo "$json" | jq 'length')
        if [[ $mapcount -gt 0 ]]; then
            echo "" >> "$CADDYFILE"
            echo "# Direct mappings" >> "$CADDYFILE"
            echo "$json" | jq -r 'to_entries[] | "\(.key).localhost {\n    reverse_proxy localhost:\(.value)\n    tls internal\n}\n"' >> "$CADDYFILE"
        fi
    else
        # fallback: use python to render mappings
        python - <<PY >> "$CADDYFILE"
import json,sys
try:
    data=json.load(open('devhost.json'))
except Exception:
    data={}
for k,v in data.items():
    print(f"{k}.localhost {{")
    print(f"    reverse_proxy localhost:{v}")
    print("    tls internal")
    print("}")
PY
    fi

    # Also update user Caddyfile if present to support system-wide caddy configs
    USER_CADDY="$HOME/.config/caddy/Caddyfile"
    if [[ -d "$(dirname "$USER_CADDY")" ]]; then
        cp "$CADDYFILE" "$USER_CADDY"
    fi

    # reload caddy if systemctl is available
    if command -v systemctl &> /dev/null; then
        sudo systemctl reload caddy || true
    fi
}

add() {
    domain=$1
    port=$2
    json=$(load_json)
    if ! [[ $port =~ ^[0-9]+$ ]]; then
        echo "Port must be a number"
        return 1
    fi
    if command -v jq &> /dev/null; then
        new_json=$(echo "$json" | jq --arg k "$domain" --arg p "$port" '. + {($k): ($p|tonumber)}')
    else
        new_json=$(python - <<PY
import json,sys
data=json.load(open('devhost.json'))
data[sys.argv[1]] = int(sys.argv[2])
print(json.dumps(data))
PY
$domain $port)
    fi
    save_json "$new_json"
    echo "[+] Mapped $domain.localhost to port $port"
    generate_caddyfile
}

remove() {
    domain=$1
    json=$(load_json)
    if command -v jq &> /dev/null; then
        new_json=$(echo "$json" | jq --arg k "$domain" 'del(.[$k])')
    else
        new_json=$(python - <<PY
import json,sys
data=json.load(open('devhost.json'))
data.pop(sys.argv[1], None)
print(json.dumps(data))
PY
$domain)
    fi
    save_json "$new_json"
    echo "[-] Removed mapping for $domain.localhost"
    generate_caddyfile
}

list() {
    json=$(load_json)
    if command -v jq &> /dev/null; then
        echo "$json" | jq
    else
        python - <<PY
import json,sys
try:
    data=json.load(sys.stdin)
except Exception:
    data={}
print(json.dumps(data, indent=2, sort_keys=True))
PY
    fi
}

START_PID_FILE=".devhost/router.pid"
START_LOG_FILE="/tmp/devhost-router.log"

start() {
    # ensure router folder
    mkdir -p .devhost
    if [ -f "$START_PID_FILE" ]; then
        pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Router already running (pid $pid)"
            return 0
        else
            rm -f "$START_PID_FILE" || true
        fi
    fi

    # prefer using a python inside a venv if available
    VENV_PYTHON=""
    if [ -x "./router/venv/bin/python" ]; then
        VENV_PYTHON="./router/venv/bin/python"
    elif [ -x "./router/venv/Scripts/python.exe" ]; then
        VENV_PYTHON="./router/venv/Scripts/python.exe"
    elif [ -x "./router/.venv/bin/python" ]; then
        VENV_PYTHON="./router/.venv/bin/python"
    elif [ -x "./router/.venv/Scripts/python.exe" ]; then
        VENV_PYTHON="./router/.venv/Scripts/python.exe"
    elif [ -x "./.venv/bin/python" ]; then
        VENV_PYTHON="./.venv/bin/python"
    elif [ -x "./.venv/Scripts/python.exe" ]; then
        VENV_PYTHON="./.venv/Scripts/python.exe"
    fi

    if [ -n "$VENV_PYTHON" ]; then
        # normalize to absolute path to avoid relative path issues when cd'ing into router
        if command -v readlink >/dev/null 2>&1; then
            VENV_PYTHON_ABS=$(readlink -f "$VENV_PYTHON" 2>/dev/null || true)
        fi
        if [ -z "${VENV_PYTHON_ABS:-}" ]; then
            VENV_PYTHON_ABS="$(cd "$(dirname "$VENV_PYTHON")" 2>/dev/null && pwd)/$(basename "$VENV_PYTHON")"
        fi
        VENV_PYTHON="$VENV_PYTHON_ABS"
        echo "Using venv python: $VENV_PYTHON"
        # ensure uvicorn installed in venv
        if ! "$VENV_PYTHON" -c "import uvicorn" >/dev/null 2>&1; then
            if [ -f "router/requirements.txt" ]; then
                echo "uvicorn not found in venv; installing requirements into venv"
                "$VENV_PYTHON" -m pip install -r router/requirements.txt || true
            fi
        fi
        START_CMD=("$VENV_PYTHON" -m uvicorn app:app --host 127.0.0.1 --port 5555)
    else
        # fallback to uvicorn binary or system python
        if [ -x "./.venv/bin/uvicorn" ]; then
            START_CMD=("$(cd "$(dirname "./.venv/bin/uvicorn")" && pwd)/$(basename "./.venv/bin/uvicorn")" "app:app" "--host" "127.0.0.1" "--port" "5555")
        elif [ -x "./router/.venv/bin/uvicorn" ]; then
            START_CMD=("$(cd "$(dirname "./router/.venv/bin/uvicorn")" && pwd)/$(basename "./router/.venv/bin/uvicorn")" "app:app" "--host" "127.0.0.1" "--port" "5555")
        elif [ -x "./router/venv/bin/uvicorn" ]; then
            START_CMD=("$(cd "$(dirname "./router/venv/bin/uvicorn")" && pwd)/$(basename "./router/venv/bin/uvicorn")" "app:app" "--host" "127.0.0.1" "--port" "5555")
        elif command -v uvicorn &>/dev/null; then
            START_CMD=("$(command -v uvicorn)" "app:app" "--host" "127.0.0.1" "--port" "5555")
        else
            START_CMD=("python3" -m uvicorn app:app --host 127.0.0.1 --port 5555)
        fi
    fi

    echo "Starting router with command: ${START_CMD[*]}"
    # start in router directory but manage pidfile from repo root
    pushd router >/dev/null 2>&1 || return 1
    nohup "${START_CMD[@]}" > "$START_LOG_FILE" 2>&1 &
    pid=$!
    popd >/dev/null 2>&1 || true
    mkdir -p "$(dirname "$START_PID_FILE")"
    echo "$pid" > "$START_PID_FILE" || { echo "Failed to write pidfile $START_PID_FILE"; return 1; }
    sleep 1
    if kill -0 "$pid" 2>/dev/null; then
        echo "Router started (pid $pid), logs: $START_LOG_FILE"
    else
        echo "Failed to start router; check $START_LOG_FILE"
        return 1
    fi
}

stop() {
    if [ ! -f "$START_PID_FILE" ]; then
        echo "Router does not appear to be running (no pidfile)."
        return 0
    fi
    pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
    if [ -z "$pid" ]; then
        echo "No pid in pidfile; removing."; rm -f "$START_PID_FILE"; return 0
    fi
    if kill -0 "$pid" 2>/dev/null; then
        kill "$pid" && echo "Sent SIGTERM to $pid" || echo "Failed to kill $pid"
        sleep 1
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" && echo "Sent SIGKILL to $pid"
        fi
    else
        echo "Process $pid not running; cleaning pidfile"
    fi
    rm -f "$START_PID_FILE"
}

status() {
    if [ -f "$START_PID_FILE" ]; then
        pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Router running (pid $pid)"
            # check health
            if command -v curl &>/dev/null; then
                if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
                    echo "Health check: OK"
                else
                    echo "Health check: not responding"
                fi
            fi
            return 0
        else
            echo "Stale pidfile found (pid $pid not running)"
            return 1
        fi
    else
        # fallback: try health endpoint
        if command -v curl &>/dev/null; then
            if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
                echo "Router responding on http://127.0.0.1:5555 (no pidfile)"
                return 0
            fi
        fi
        echo "Router not running"
        return 1
    fi
}

case "$1" in
    add) add $2 $3 ;;
    remove) remove $2 ;;
    list) list ;;
    start) start ;;
    stop) stop ;;
    status) status ;;
    install)
        # support: devhost install --macos  OR devhost install macos
        if [[ "$2" == "--macos" || "$2" == "macos" ]]; then
            if [[ -x "scripts/setup-macos.sh" ]]; then
                bash scripts/setup-macos.sh "${@:3}"
            else
                bash ./scripts/setup-macos.sh "${@:3}"
            fi
        else
            echo "Usage: devhost install --macos"
            exit 1
        fi
        ;;
    *) echo "Usage: devhost {add|remove|list|install --macos [--yes] [--start-dns]}";;
esac
