"""
External proxy integration for Devhost v3.0

Provides snippet generation, attach/detach, discovery, and transfer for:
- Caddy
- Nginx
- Traefik
"""

import re
from datetime import datetime, timezone
from pathlib import Path
from typing import Literal

import httpx

from .output import console, print_error, print_info, print_success, print_warning
from .state import StateConfig

ProxyDriver = Literal["caddy", "nginx", "traefik"]

# Marker comments for attach/detach
MARKER_BEGIN = "# devhost: begin"
MARKER_END = "# devhost: end"


# ─────────────────────────────────────────────────────────────────────────────
# Snippet Generation
# ─────────────────────────────────────────────────────────────────────────────


def _generate_caddy_snippet(routes: dict[str, dict], domain: str) -> str:
    """Generate Caddy config snippet for all routes."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    active_routes = {name: r for name, r in routes.items() if r.get("enabled", True)}

    lines = [
        "# Auto-generated by Devhost - do not edit",
        f"# Last updated: {timestamp}",
        f"# Routes: {len(active_routes)} active",
        "",
    ]

    for name, route in sorted(active_routes.items()):
        upstream = route.get("upstream", "127.0.0.1:8000")
        route_domain = route.get("domain", domain)

        # Build the host
        host = f"{name}.{route_domain}"

        lines.append(f"{host} {{")
        # Use 127.0.0.1 instead of localhost to avoid IPv6 surprises
        if not upstream.startswith("http"):
            upstream = f"http://{upstream}"
        lines.append(f"    reverse_proxy {upstream}")
        lines.append("}")
        lines.append("")

    return "\n".join(lines)


def _generate_nginx_snippet(routes: dict[str, dict], domain: str) -> str:
    """Generate nginx config snippet for all routes."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    active_routes = {name: r for name, r in routes.items() if r.get("enabled", True)}

    lines = [
        "# Auto-generated by Devhost - do not edit",
        f"# Last updated: {timestamp}",
        f"# Include in nginx.conf: include {Path.home()}/.devhost/proxy/nginx/devhost.conf;",
        "",
    ]

    for name, route in sorted(active_routes.items()):
        upstream = route.get("upstream", "127.0.0.1:8000")
        route_domain = route.get("domain", domain)
        host = f"{name}.{route_domain}"

        # Preserve upstream scheme for proxy_pass
        upstream_scheme = "http"
        if upstream.startswith("https://"):
            upstream_scheme = "https"
            upstream = upstream[8:]
        elif upstream.startswith("http://"):
            upstream_scheme = "http"
            upstream = upstream[7:]

        lines.extend(
            [
                "server {",
                "    listen 80;",
                f"    server_name {host};",
                "    location / {",
                f"        proxy_pass {upstream_scheme}://{upstream};",
                "        proxy_http_version 1.1;",
                "        proxy_set_header Host $host;",
                "        proxy_set_header X-Real-IP $remote_addr;",
                "        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;",
                "        proxy_set_header X-Forwarded-Proto $scheme;",
                "    }",
                "}",
                "",
            ]
        )

    return "\n".join(lines)


def _generate_traefik_snippet(routes: dict[str, dict], domain: str) -> str:
    """Generate Traefik config snippet (YAML format) for all routes."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    active_routes = {name: r for name, r in routes.items() if r.get("enabled", True)}

    lines = [
        "# Auto-generated by Devhost - do not edit",
        f"# Last updated: {timestamp}",
        "# Add to traefik.yml: providers.file.filename: ~/.devhost/proxy/traefik/devhost.yml",
        "",
        "http:",
        "  routers:",
    ]

    # Generate routers
    for name, route in sorted(active_routes.items()):
        route_domain = route.get("domain", domain)
        host = f"{name}.{route_domain}"
        lines.extend(
            [
                f"    {name}:",
                f'      rule: "Host(`{host}`)"',
                f"      service: {name}-service",
            ]
        )

    lines.extend(
        [
            "",
            "  services:",
        ]
    )

    # Generate services
    for name, route in sorted(active_routes.items()):
        upstream = route.get("upstream", "127.0.0.1:8000")
        if not upstream.startswith("http"):
            upstream = f"http://{upstream}"

        lines.extend(
            [
                f"    {name}-service:",
                "      loadBalancer:",
                "        servers:",
                f'          - url: "{upstream}"',
            ]
        )

    return "\n".join(lines)


def generate_snippet(driver: ProxyDriver, routes: dict[str, dict], domain: str = "localhost") -> str:
    """Generate proxy config snippet for the specified driver."""
    generators = {
        "caddy": _generate_caddy_snippet,
        "nginx": _generate_nginx_snippet,
        "traefik": _generate_traefik_snippet,
    }
    generator = generators.get(driver)
    if not generator:
        raise ValueError(f"Unsupported proxy driver: {driver}")
    return generator(routes, domain)


def export_snippets(state: StateConfig, drivers: list[ProxyDriver] | None = None) -> dict[str, Path]:
    """
    Export snippets for specified drivers (or all if None).

    Returns dict of driver -> exported file path.
    """
    if drivers is None:
        drivers = ["caddy", "nginx", "traefik"]

    routes = state.routes
    domain = state.system_domain
    exported = {}

    extensions = {"caddy": "caddy", "nginx": "conf", "traefik": "yml"}

    for driver in drivers:
        ext = extensions.get(driver, "conf")
        snippet_path = state.devhost_dir / "proxy" / driver / f"devhost.{ext}"
        snippet_path.parent.mkdir(parents=True, exist_ok=True)

        content = generate_snippet(driver, routes, domain)
        snippet_path.write_text(content, encoding="utf-8")

        # Record hash for integrity tracking
        state.record_hash(snippet_path)
        exported[driver] = snippet_path

    return exported


# ─────────────────────────────────────────────────────────────────────────────
# Proxy Discovery
# ─────────────────────────────────────────────────────────────────────────────


def _get_search_paths(driver: ProxyDriver) -> list[Path]:
    """Get search paths for a proxy driver's config file."""
    home = Path.home()
    cwd = Path.cwd()

    paths = {
        "caddy": [
            cwd / "Caddyfile",
            cwd / "caddy" / "Caddyfile",
            home / ".config" / "caddy" / "Caddyfile",
            Path("/etc/caddy/Caddyfile"),
            # Windows paths
            Path("C:/ProgramData/caddy/Caddyfile"),
        ],
        "nginx": [
            cwd / "nginx.conf",
            cwd / "nginx" / "nginx.conf",
            home / ".config" / "nginx" / "nginx.conf",
            Path("/etc/nginx/nginx.conf"),
            Path("/usr/local/etc/nginx/nginx.conf"),
            # Windows paths
            Path("C:/nginx/conf/nginx.conf"),
        ],
        "traefik": [
            cwd / "traefik.yml",
            cwd / "traefik.yaml",
            cwd / "traefik" / "traefik.yml",
            home / ".config" / "traefik" / "traefik.yml",
            Path("/etc/traefik/traefik.yml"),
        ],
    }
    return paths.get(driver, [])


def discover_proxy_config(driver: ProxyDriver | None = None) -> list[tuple[ProxyDriver, Path]]:
    """
    Discover proxy config files on the system.

    If driver is specified, only search for that driver.
    Returns list of (driver, path) tuples for found configs.
    """
    drivers_to_check: list[ProxyDriver] = [driver] if driver else ["caddy", "nginx", "traefik"]
    found = []

    for drv in drivers_to_check:
        for path in _get_search_paths(drv):
            if path.exists():
                found.append((drv, path))

    return found


def print_discovery_results(results: list[tuple[ProxyDriver, Path]]):
    """Print discovered proxy configs in a formatted way."""
    if not results:
        print_warning("No proxy configurations found.")
        print_info("\nSearched locations include:")
        console.print("  - ./Caddyfile, ./nginx.conf, ./traefik.yml")
        console.print("  - ~/.config/{caddy,nginx,traefik}/")
        console.print("  - /etc/{caddy,nginx,traefik}/")
        return

    print_success(f"Found {len(results)} proxy configuration(s):")
    for i, (driver, path) in enumerate(results, 1):
        console.print(f"  [{i}] {driver}: [cyan]{path}[/cyan]")


# ─────────────────────────────────────────────────────────────────────────────
# Attach / Detach
# ─────────────────────────────────────────────────────────────────────────────


def _get_import_line(driver: ProxyDriver, snippet_path: Path) -> str:
    """Get the import/include line for a driver."""
    abs_path = str(snippet_path.resolve())

    imports = {
        "caddy": f"import {abs_path}",
        "nginx": f"include {abs_path};",
        "traefik": f"# File provider: {abs_path}",  # Traefik uses file provider in main config
    }
    return imports.get(driver, f"# include {abs_path}")


def _create_marker_block(driver: ProxyDriver, snippet_path: Path) -> str:
    """Create the marker block to insert into user config."""
    import_line = _get_import_line(driver, snippet_path)
    return f"{MARKER_BEGIN}\n{import_line}\n{MARKER_END}"


def has_marker_block(content: str) -> bool:
    """Check if content already has a devhost marker block."""
    return MARKER_BEGIN in content and MARKER_END in content


def extract_marker_block(content: str) -> str | None:
    """Extract the marker block from content if present."""
    if MARKER_BEGIN not in content or MARKER_END not in content:
        return None

    start = content.find(MARKER_BEGIN)
    end = content.find(MARKER_END) + len(MARKER_END)
    return content[start:end]


def attach_to_config(
    state: StateConfig,
    config_path: Path,
    driver: ProxyDriver,
) -> tuple[bool, str]:
    """
    Attach devhost snippet import to a proxy config file.

    Returns (success, message).
    """
    if not config_path.exists():
        return (False, f"Config file not found: {config_path}")

    # Read current content
    content = config_path.read_text(encoding="utf-8")

    # Check if already attached
    if has_marker_block(content):
        return (False, "Devhost marker block already exists. Use 'detach' first to re-attach.")

    # Backup the file
    backup_path = state.backup_file(config_path)
    if backup_path:
        print_info(f"Backup created: {backup_path}")
    else:
        print_warning("Could not create backup (file may not exist or permission denied)")

    # Generate snippet first
    snippet_path = state.devhost_dir / "proxy" / driver / f"devhost.{_get_extension(driver)}"
    if not snippet_path.exists():
        # Export snippet if it doesn't exist
        export_snippets(state, [driver])

    # Create and insert marker block
    marker_block = _create_marker_block(driver, snippet_path)

    lines = content.split("\n")

    def _strip_nginx_comment(line: str) -> str:
        if "#" in line:
            return line.split("#", 1)[0]
        return line

    def _indent_block(block: str, indent: str) -> list[str]:
        return [f"{indent}{line}" if line else line for line in block.splitlines()]

    def _find_nginx_http_insert(lines_in: list[str]) -> tuple[int, str] | None:
        depth = 0
        for idx, raw in enumerate(lines_in):
            no_comment = _strip_nginx_comment(raw)
            stripped = no_comment.strip()

            if depth == 0:
                if re.match(r"^http\b\s*\{", stripped):
                    indent = re.match(r"^(\s*)", raw).group(1) + "    "
                    return (idx + 1, indent)
                if stripped == "http":
                    for j in range(idx + 1, len(lines_in)):
                        next_raw = lines_in[j]
                        next_stripped = _strip_nginx_comment(next_raw).strip()
                        if not next_stripped:
                            continue
                        if next_stripped.startswith("{"):
                            indent = re.match(r"^(\s*)", next_raw).group(1) + "    "
                            return (j + 1, indent)
                        break

            depth += no_comment.count("{") - no_comment.count("}")

        return None

    if driver == "nginx":
        nginx_insert = _find_nginx_http_insert(lines)
        if nginx_insert:
            insert_idx, indent = nginx_insert
            marker_lines = _indent_block(marker_block, indent)
            lines[insert_idx:insert_idx] = ["", *marker_lines, ""]
        else:
            # Assume conf.d-style file already included within http context
            insert_idx = 0
            for i, line in enumerate(lines):
                stripped = line.strip()
                if stripped and not stripped.startswith("#") and not stripped.startswith("//"):
                    insert_idx = i
                    break
                insert_idx = i + 1
            lines[insert_idx:insert_idx] = ["", marker_block, ""]
    else:
        # Insert at the beginning of the file (after any initial comments)
        insert_idx = 0
        for i, line in enumerate(lines):
            stripped = line.strip()
            if stripped and not stripped.startswith("#") and not stripped.startswith("//"):
                insert_idx = i
                break
            insert_idx = i + 1

        lines.insert(insert_idx, "")
        lines.insert(insert_idx + 1, marker_block)
        lines.insert(insert_idx + 2, "")

    new_content = "\n".join(lines)
    config_path.write_text(new_content, encoding="utf-8")

    # Record hash for drift detection
    state.record_hash(config_path)

    # Update state with external config
    state.set_external_config(driver, str(config_path))

    return (True, f"Attached devhost to {config_path}")


def detach_from_config(state: StateConfig, config_path: Path) -> tuple[bool, str]:
    """
    Remove devhost marker block from a proxy config file.

    Returns (success, message).
    """
    if not config_path.exists():
        return (False, f"Config file not found: {config_path}")

    content = config_path.read_text(encoding="utf-8")

    if not has_marker_block(content):
        return (False, "No devhost marker block found in config")

    # Check for drift before detaching
    ok, status = state.check_hash(config_path)
    if not ok and status == "modified":
        print_warning("Config file has been modified since last attach.")
        print_warning("The marker block may have been changed. Proceeding with caution.")

    # Backup before detaching
    backup_path = state.backup_file(config_path)
    if backup_path:
        print_info(f"Backup created: {backup_path}")

    # Remove marker block
    start = content.find(MARKER_BEGIN)
    end = content.find(MARKER_END) + len(MARKER_END)

    # Also remove surrounding blank lines
    before = content[:start].rstrip("\n")
    after = content[end:].lstrip("\n")

    new_content = before + "\n\n" + after if before else after

    config_path.write_text(new_content, encoding="utf-8")

    # Record hash for drift detection
    state.record_hash(config_path)

    return (True, f"Detached devhost from {config_path}")


def _get_extension(driver: ProxyDriver) -> str:
    """Get file extension for a driver."""
    return {"caddy": "caddy", "nginx": "conf", "traefik": "yml"}.get(driver, "conf")


# ─────────────────────────────────────────────────────────────────────────────
# Transfer (Mode 2 -> Mode 3)
# ─────────────────────────────────────────────────────────────────────────────


def verify_route(host: str, port: int = 80, timeout: float = 2.0) -> tuple[bool, str]:
    """
    Verify a route is accessible through the proxy.

    Sends a request with Host header and checks for non-error response.
    Returns (success, message).
    """
    try:
        url = f"http://127.0.0.1:{port}/"
        response = httpx.get(url, headers={"Host": host}, timeout=timeout, follow_redirects=False)

        # Accept any 2xx, 3xx, or even some 4xx (like 401/403 which indicate routing works)
        if response.status_code < 500:
            return (True, f"OK ({response.status_code})")
        return (False, f"Server error ({response.status_code})")
    except httpx.ConnectError:
        return (False, "Connection refused")
    except httpx.TimeoutException:
        return (False, "Timeout")
    except Exception as e:
        return (False, str(e))


def verify_all_routes(
    state: StateConfig,
    port: int = 80,
) -> dict[str, tuple[bool, str]]:
    """
    Verify all routes through the external proxy.

    Returns dict of route_name -> (success, message).
    """
    results = {}
    domain = state.system_domain

    for name, route in state.routes.items():
        if not route.get("enabled", True):
            results[name] = (True, "Disabled (skipped)")
            continue

        route_domain = route.get("domain", domain)
        host = f"{name}.{route_domain}"
        results[name] = verify_route(host, port)

    return results


def transfer_to_external(
    state: StateConfig,
    driver: ProxyDriver,
    config_path: Path | None = None,
    auto_attach: bool = True,
    verify: bool = True,
    port: int = 80,
) -> tuple[bool, str]:
    """
    Transfer from Mode 2 (system) to Mode 3 (external).

    Steps:
    1. Generate snippets for all routes
    2. Optionally attach into external proxy config
    3. Verify routes if requested
    4. Switch proxy mode to external

    Returns (success, message).
    """
    print_info("Starting transfer to external proxy mode...")

    # Step 1: Generate snippets
    print_info("Generating proxy snippets...")
    exported = export_snippets(state, [driver])
    snippet_path = exported.get(driver)
    if snippet_path:
        print_success(f"Snippet exported: {snippet_path}")

    # Step 2: Attach if requested
    if auto_attach:
        if config_path is None:
            # Try to discover
            found = discover_proxy_config(driver)
            if not found:
                return (False, f"No {driver} config found. Specify --config-path or run 'proxy attach' manually.")
            config_path = found[0][1]
            print_info(f"Using discovered config: {config_path}")

        success, msg = attach_to_config(state, config_path, driver)
        if not success:
            return (False, f"Attach failed: {msg}")
        print_success(msg)
    else:
        # Persist external driver/config even when attach is skipped
        if config_path is not None:
            state.set_external_config(driver, str(config_path))
        else:
            state.set_external_config(driver)

    # Step 3: Verify routes
    if verify:
        print_info("Verifying routes through external proxy...")
        results = verify_all_routes(state, port)

        all_ok = True
        for name, (ok, status) in results.items():
            if ok:
                print_success(f"  {name}: {status}")
            else:
                print_error(f"  {name}: {status}")
                all_ok = False

        if not all_ok:
            print_warning("\nSome routes failed verification.")
            print_warning("The external proxy may need to be reloaded.")
            print_warning("Transfer aborted. Fix issues and try again.")
            return (False, "Route verification failed")

    # Step 4: Switch mode
    state.proxy_mode = "external"
    print_success(f"Proxy mode switched to: external ({driver})")

    return (True, "Transfer complete")


# ─────────────────────────────────────────────────────────────────────────────
# CLI Handlers
# ─────────────────────────────────────────────────────────────────────────────


def cmd_proxy_export(driver: str | None = None, show: bool = False):
    """Handle 'devhost proxy export' command."""
    state = StateConfig()

    if state.route_count() == 0:
        print_warning("No routes configured. Add some routes first with 'devhost add'.")
        return

    drivers: list[ProxyDriver] = [driver] if driver else ["caddy", "nginx", "traefik"]

    if show:
        # Just print the snippet without saving
        for drv in drivers:
            content = generate_snippet(drv, state.routes, state.system_domain)
            console.print(f"\n[bold cyan]─── {drv.upper()} ───[/bold cyan]")
            console.print(content)
        return

    exported = export_snippets(state, drivers)
    print_success("Exported proxy snippets:")
    for drv, path in exported.items():
        console.print(f"  {drv}: [cyan]{path}[/cyan]")

    print_info("\nNext steps:")
    console.print("  1. Review the generated snippets")
    console.print("  2. Run 'devhost proxy attach' to add to your proxy config")
    console.print("  3. Or manually include the snippet in your proxy config")


def cmd_proxy_discover():
    """Handle 'devhost proxy discover' command."""
    results = discover_proxy_config()
    print_discovery_results(results)


def cmd_proxy_attach(driver: str, config_path: str | None = None):
    """Handle 'devhost proxy attach' command."""
    state = StateConfig()

    if config_path:
        path = Path(config_path)
    else:
        # Try to discover
        found = discover_proxy_config(driver)
        if not found:
            print_error(f"No {driver} config found. Specify --config-path.")
            return
        if len(found) > 1:
            print_warning("Multiple configs found. Specify --config-path:")
            for drv, p in found:
                console.print(f"  {drv}: {p}")
            return
        path = found[0][1]

    success, msg = attach_to_config(state, path, driver)
    if success:
        print_success(msg)
        print_info("\nRemember to reload your proxy to apply changes.")
    else:
        print_error(msg)


def cmd_proxy_detach(config_path: str | None = None):
    """Handle 'devhost proxy detach' command."""
    state = StateConfig()

    if config_path:
        path = Path(config_path)
    else:
        # Use configured path
        path = state.external_config_path
        if not path:
            print_error("No external config path configured. Specify --config-path.")
            return

    success, msg = detach_from_config(state, path)
    if success:
        print_success(msg)
    else:
        print_error(msg)


def cmd_proxy_transfer(
    driver: str,
    config_path: str | None = None,
    no_attach: bool = False,
    no_verify: bool = False,
    port: int = 80,
):
    """Handle 'devhost proxy transfer' command."""
    state = StateConfig()

    if state.route_count() == 0:
        print_warning("No routes configured. Add some routes first with 'devhost add'.")
        return

    path = Path(config_path) if config_path else None
    success, msg = transfer_to_external(
        state,
        driver,
        config_path=path,
        auto_attach=not no_attach,
        verify=not no_verify,
        port=port,
    )

    if success:
        print_success(msg)
    else:
        print_error(msg)
