#!/usr/bin/env bash

SCRIPT_PATH="${BASH_SOURCE[0]}"
if command -v readlink >/dev/null 2>&1; then
    SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH" 2>/dev/null || echo "$SCRIPT_PATH")"
fi
ROOT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
CONFIG="$ROOT_DIR/devhost.json"
CADDYFILE="$ROOT_DIR/caddy/Caddyfile"
PYTHON_BIN=""
if command -v python3 &> /dev/null; then
    PYTHON_BIN="python3"
elif command -v python &> /dev/null; then
    PYTHON_BIN="python"
fi

load_json() {
    if [[ ! -f "$CONFIG" ]]; then
        echo "{}" > "$CONFIG"
    fi
    cat "$CONFIG"
}

save_json() {
    echo "$1" > "$CONFIG"
}

first_mapping_name() {
    if command -v jq &> /dev/null; then
        jq -r 'keys[0] // empty' "$CONFIG"
    elif [ -n "$PYTHON_BIN" ]; then
        "$PYTHON_BIN" - "$CONFIG" <<'PY'
import json,sys
try:
    data=json.load(open(sys.argv[1]))
    keys=sorted(data.keys())
    print(keys[0] if keys else "")
except Exception:
    print("")
PY
    else
        echo ""
    fi
}

get_port_for_name() {
    name=$1
    if command -v jq &> /dev/null; then
        jq -r --arg k "$name" '.[$k] // empty' "$CONFIG"
    elif [ -n "$PYTHON_BIN" ]; then
        "$PYTHON_BIN" - "$CONFIG" "$name" <<'PY'
import json,sys
try:
    data=json.load(open(sys.argv[1]))
    print(data.get(sys.argv[2], ""))
except Exception:
    print("")
PY
    else
        echo ""
    fi
}

open_in_browser() {
    url=$1
    if command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$url" >/dev/null 2>&1 &
    elif command -v open >/dev/null 2>&1; then
        open "$url" >/dev/null 2>&1 &
    elif command -v powershell.exe >/dev/null 2>&1; then
        powershell.exe -NoProfile -Command "Start-Process '$url'" >/dev/null 2>&1
    elif [ -n "$PYTHON_BIN" ]; then
        "$PYTHON_BIN" - <<PY >/dev/null 2>&1
import webbrowser
webbrowser.open("$url")
PY
    else
        echo "No supported browser opener found (xdg-open/open/powershell/python)."
        return 1
    fi
}

print_usage() {
    cat <<'EOF'
Usage: devhost <command> [args]

Commands:
  add <name> <port>       Add a mapping
  remove <name>           Remove a mapping
  list                    List mappings
  url [name]              Print HTTPS URL; press Ctrl+O to open (interactive)
  open [name]             Open HTTPS URL in default browser
  validate                Quick config/router/DNS checks
  export caddy            Print generated Caddyfile
  edit                    Open devhost.json in $EDITOR (fallback: vi)
  resolve <name>          Show DNS resolution and port reachability
  doctor                  Deeper diagnostics (dnsmasq/systemd-resolved/Caddy)
  info                    Show this help
  start|stop|status       Manage router process
  install --macos [...]   Run macOS installer
EOF
}

edit_config() {
    editor="${EDITOR:-}"
    if [ -z "$editor" ]; then
        if command -v nano >/dev/null 2>&1; then
            editor="nano"
        elif command -v vi >/dev/null 2>&1; then
            editor="vi"
        else
            echo "No editor found. Set \$EDITOR or install nano/vi."
            return 1
        fi
    fi
    "$editor" "$CONFIG"
}

resolve_mapping() {
    name=$1
    if [ -z "$name" ]; then
        echo "Usage: devhost resolve <name>"
        return 1
    fi
    port=$(get_port_for_name "$name")
    if [ -z "$port" ]; then
        echo "No mapping found for ${name}.localhost"
    else
        echo "${name}.localhost -> port ${port}"
    fi

    if command -v dig >/dev/null 2>&1; then
        ip=$(dig +short "${name}.localhost" | head -n 1)
        if [ -n "$ip" ]; then
            echo "DNS: ${name}.localhost -> ${ip}"
        else
            echo "DNS: unresolved"
        fi
    elif command -v getent >/dev/null 2>&1; then
        ip=$(getent hosts "${name}.localhost" | awk '{print $1}' | head -n 1)
        if [ -n "$ip" ]; then
            echo "DNS: ${name}.localhost -> ${ip}"
        else
            echo "DNS: unresolved"
        fi
    else
        echo "DNS: dig/getent not available"
    fi

    if [ -n "$port" ] && command -v nc >/dev/null 2>&1; then
        if nc -z 127.0.0.1 "$port" >/dev/null 2>&1; then
            echo "Port: 127.0.0.1:${port} is open"
        else
            echo "Port: 127.0.0.1:${port} is not reachable"
        fi
    elif [ -n "$port" ]; then
        echo "Port: nc not available to test reachability"
    fi
}

doctor() {
    echo "Devhost doctor"
    echo "Root: $ROOT_DIR"
    echo "Config: $CONFIG"
    validate || true

    if command -v systemctl >/dev/null 2>&1; then
        if systemctl is-active --quiet caddy; then
            echo "Caddy: active"
        elif systemctl status caddy >/dev/null 2>&1; then
            echo "Caddy: installed but not active"
        else
            echo "Caddy: not found"
        fi

        if systemctl is-active --quiet dnsmasq; then
            echo "dnsmasq: active"
        elif systemctl status dnsmasq >/dev/null 2>&1; then
            echo "dnsmasq: installed but not active"
        else
            echo "dnsmasq: not found"
        fi

        if systemctl is-active --quiet systemd-resolved; then
            echo "systemd-resolved: active"
            if command -v resolvectl >/dev/null 2>&1; then
                resolvectl status 2>/dev/null | sed -n '1,60p'
            fi
        else
            echo "systemd-resolved: not active"
        fi
    else
        echo "systemctl not available; skipping service checks"
    fi
}

generate_caddyfile() {
    # generate project-local Caddyfile and a user-level Caddyfile if present
    echo "# Autogenerated Caddyfile" > "$CADDYFILE"
    echo "*.localhost {" >> "$CADDYFILE"
    echo "    reverse_proxy localhost:5555" >> "$CADDYFILE"
    echo "    tls internal" >> "$CADDYFILE"
    echo "}" >> "$CADDYFILE"

    # Append explicit mappings from devhost.json
    json=$(load_json)
    if command -v jq &> /dev/null; then
        mapcount=$(echo "$json" | jq 'length')
        if [[ $mapcount -gt 0 ]]; then
            echo "" >> "$CADDYFILE"
            echo "# Direct mappings" >> "$CADDYFILE"
            echo "$json" | jq -r 'to_entries[] | "\(.key).localhost {\n    reverse_proxy localhost:\(.value)\n    tls internal\n}\n"' >> "$CADDYFILE"
        fi
    else
        # fallback: use python to render mappings
        if [ -z "$PYTHON_BIN" ]; then
            echo "python3 (or python) is required to render mappings without jq."
            return 1
        fi
        "$PYTHON_BIN" - "$CONFIG" <<PY >> "$CADDYFILE"
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
for k,v in data.items():
    print(f"{k}.localhost {{")
    print(f"    reverse_proxy localhost:{v}")
    print("    tls internal")
    print("}")
PY
    fi

    # Also update user Caddyfile if present to support system-wide caddy configs
    USER_CADDY="$HOME/.config/caddy/Caddyfile"
    if [[ -d "$(dirname "$USER_CADDY")" ]]; then
        cp "$CADDYFILE" "$USER_CADDY"
    fi

    # reload caddy if systemctl is available
    if command -v systemctl &> /dev/null; then
        sudo systemctl reload caddy || true
    fi
}

print_caddyfile() {
    echo "# Autogenerated Caddyfile"
    echo "*.localhost {"
    echo "    reverse_proxy localhost:5555"
    echo "    tls internal"
    echo "}"

    json=$(load_json)
    if command -v jq &> /dev/null; then
        mapcount=$(echo "$json" | jq 'length')
        if [[ $mapcount -gt 0 ]]; then
            echo ""
            echo "# Direct mappings"
            echo "$json" | jq -r 'to_entries[] | "\(.key).localhost {\n    reverse_proxy localhost:\(.value)\n    tls internal\n}\n"'
        fi
    else
        if [ -z "$PYTHON_BIN" ]; then
            echo "python3 (or python) is required to render mappings without jq."
            return 1
        fi
        "$PYTHON_BIN" - "$CONFIG" <<PY
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
for k,v in data.items():
    print(f"{k}.localhost {{")
    print(f"    reverse_proxy localhost:{v}")
    print("    tls internal")
    print("}")
PY
    fi
}

add() {
    domain=$1
    port=$2
    json=$(load_json)
    if ! [[ $port =~ ^[0-9]+$ ]]; then
        echo "Port must be a number"
        return 1
    fi
    if command -v jq &> /dev/null; then
        new_json=$(echo "$json" | jq --arg k "$domain" --arg p "$port" '. + {($k): ($p|tonumber)}')
    else
        if [ -z "$PYTHON_BIN" ]; then
            echo "python3 (or python) is required to add mappings without jq."
            return 1
        fi
        new_json=$("$PYTHON_BIN" - "$CONFIG" "$domain" "$port" <<PY
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
data[sys.argv[2]] = int(sys.argv[3])
print(json.dumps(data))
PY
)
    fi
    save_json "$new_json"
    echo "[+] Mapped $domain.localhost to port $port"
    generate_caddyfile
}

remove() {
    domain=$1
    json=$(load_json)
    if command -v jq &> /dev/null; then
        new_json=$(echo "$json" | jq --arg k "$domain" 'del(.[$k])')
    else
        if [ -z "$PYTHON_BIN" ]; then
            echo "python3 (or python) is required to remove mappings without jq."
            return 1
        fi
        new_json=$("$PYTHON_BIN" - "$CONFIG" "$domain" <<PY
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
data.pop(sys.argv[2], None)
print(json.dumps(data))
PY
)
    fi
    save_json "$new_json"
    echo "[-] Removed mapping for $domain.localhost"
    generate_caddyfile
}

list() {
    if command -v jq &> /dev/null; then
        load_json | jq
    else
        if [ -z "$PYTHON_BIN" ]; then
            load_json
            return 0
        fi
        "$PYTHON_BIN" - "$CONFIG" <<PY
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
print(json.dumps(data, indent=2, sort_keys=True))
PY
    fi
}

url() {
    name=$1
    if [ -z "$name" ]; then
        name=$(first_mapping_name)
        if [ -z "$name" ]; then
            echo "No mappings found. Add one with: devhost add <name> <port>"
            return 1
        fi
    fi
    echo "https://${name}.localhost"
    # Optional: open when Ctrl+O is pressed (interactive only)
    if [ -t 0 ]; then
        read -r -n 1 -s -p "Press Ctrl+O to open in browser, any other key to skip... " key
        echo
        if [ "$key" = $'\x0f' ]; then
            open_in_browser "https://${name}.localhost"
        fi
    fi
}

open_cmd() {
    name=$1
    if [ -z "$name" ]; then
        name=$(first_mapping_name)
        if [ -z "$name" ]; then
            echo "No mappings found. Add one with: devhost add <name> <port>"
            return 1
        fi
    fi
    open_in_browser "https://${name}.localhost"
}

validate() {
    echo "Config: $CONFIG"
    if [ ! -f "$CONFIG" ]; then
        echo "Config file missing."
        return 1
    fi

    if command -v jq &> /dev/null; then
        if ! jq empty "$CONFIG" >/dev/null 2>&1; then
            echo "Config JSON: invalid"
            return 1
        fi
    elif [ -n "$PYTHON_BIN" ]; then
        if ! "$PYTHON_BIN" - "$CONFIG" <<'PY' >/dev/null 2>&1
import json,sys
json.load(open(sys.argv[1]))
PY
        then
            echo "Config JSON: invalid"
            return 1
        fi
    fi
    echo "Config JSON: OK"

    if command -v curl &>/dev/null; then
        if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
            echo "Router: OK"
        else
            echo "Router: not responding"
        fi
    else
        echo "Router: curl not available"
    fi

    name=$(first_mapping_name)
    if [ -n "$name" ]; then
        if command -v dig >/dev/null 2>&1; then
            if dig +short "${name}.localhost" | grep -q '127.0.0.1'; then
                echo "DNS: OK (${name}.localhost -> 127.0.0.1)"
            else
                echo "DNS: unresolved for ${name}.localhost"
            fi
        elif command -v getent >/dev/null 2>&1; then
            if getent hosts "${name}.localhost" | grep -q '127.0.0.1'; then
                echo "DNS: OK (${name}.localhost -> 127.0.0.1)"
            else
                echo "DNS: unresolved for ${name}.localhost"
            fi
        else
            echo "DNS: dig/getent not available"
        fi
    else
        echo "DNS: no mappings to test"
    fi
}

START_PID_FILE="$ROOT_DIR/.devhost/router.pid"
START_LOG_FILE="/tmp/devhost-router.log"

start() {
    # ensure router folder
    mkdir -p "$(dirname "$START_PID_FILE")"
    if [ -f "$START_PID_FILE" ]; then
        pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Router already running (pid $pid)"
            return 0
        else
            rm -f "$START_PID_FILE" || true
        fi
    fi

    # prefer using a python inside a venv if available
    VENV_PYTHON=""
    if [ -x "$ROOT_DIR/router/venv/bin/python" ]; then
        VENV_PYTHON="$ROOT_DIR/router/venv/bin/python"
    elif [ -x "$ROOT_DIR/router/venv/Scripts/python.exe" ]; then
        VENV_PYTHON="$ROOT_DIR/router/venv/Scripts/python.exe"
    elif [ -x "$ROOT_DIR/router/.venv/bin/python" ]; then
        VENV_PYTHON="$ROOT_DIR/router/.venv/bin/python"
    elif [ -x "$ROOT_DIR/router/.venv/Scripts/python.exe" ]; then
        VENV_PYTHON="$ROOT_DIR/router/.venv/Scripts/python.exe"
    elif [ -x "$ROOT_DIR/.venv/bin/python" ]; then
        VENV_PYTHON="$ROOT_DIR/.venv/bin/python"
    elif [ -x "$ROOT_DIR/.venv/Scripts/python.exe" ]; then
        VENV_PYTHON="$ROOT_DIR/.venv/Scripts/python.exe"
    fi

    if [ -n "$VENV_PYTHON" ]; then
        # normalize to absolute path to avoid relative path issues when cd'ing into router
        if command -v readlink >/dev/null 2>&1; then
            VENV_PYTHON_ABS=$(readlink -f "$VENV_PYTHON" 2>/dev/null || true)
        fi
        if [ -z "${VENV_PYTHON_ABS:-}" ]; then
            VENV_PYTHON_ABS="$(cd "$(dirname "$VENV_PYTHON")" 2>/dev/null && pwd)/$(basename "$VENV_PYTHON")"
        fi
        VENV_PYTHON="$VENV_PYTHON_ABS"
        echo "Using venv python: $VENV_PYTHON"
        # ensure uvicorn installed in venv
        if ! "$VENV_PYTHON" -c "import uvicorn" >/dev/null 2>&1; then
        if [ -f "$ROOT_DIR/router/requirements.txt" ]; then
            echo "uvicorn not found in venv; installing requirements into venv"
            "$VENV_PYTHON" -m pip install -r "$ROOT_DIR/router/requirements.txt" || true
        fi
        fi
        START_CMD=("$VENV_PYTHON" -m uvicorn app:app --host 127.0.0.1 --port 5555)
    else
        # fallback to uvicorn binary or system python
        if [ -x "$ROOT_DIR/.venv/bin/uvicorn" ]; then
            START_CMD=("$(cd "$(dirname "$ROOT_DIR/.venv/bin/uvicorn")" && pwd)/$(basename "$ROOT_DIR/.venv/bin/uvicorn")" "app:app" "--host" "127.0.0.1" "--port" "5555")
        elif [ -x "$ROOT_DIR/router/.venv/bin/uvicorn" ]; then
            START_CMD=("$(cd "$(dirname "$ROOT_DIR/router/.venv/bin/uvicorn")" && pwd)/$(basename "$ROOT_DIR/router/.venv/bin/uvicorn")" "app:app" "--host" "127.0.0.1" "--port" "5555")
        elif [ -x "$ROOT_DIR/router/venv/bin/uvicorn" ]; then
            START_CMD=("$(cd "$(dirname "$ROOT_DIR/router/venv/bin/uvicorn")" && pwd)/$(basename "$ROOT_DIR/router/venv/bin/uvicorn")" "app:app" "--host" "127.0.0.1" "--port" "5555")
        elif command -v uvicorn &>/dev/null; then
            START_CMD=("$(command -v uvicorn)" "app:app" "--host" "127.0.0.1" "--port" "5555")
        else
            START_CMD=("python3" -m uvicorn app:app --host 127.0.0.1 --port 5555)
        fi
    fi

    echo "Starting router with command: ${START_CMD[*]}"
    # start in router directory but manage pidfile from repo root
    pushd "$ROOT_DIR/router" >/dev/null 2>&1 || return 1
    nohup "${START_CMD[@]}" > "$START_LOG_FILE" 2>&1 &
    pid=$!
    popd >/dev/null 2>&1 || true
    echo "$pid" > "$START_PID_FILE" || { echo "Failed to write pidfile $START_PID_FILE"; return 1; }
    sleep 1
    if kill -0 "$pid" 2>/dev/null; then
        echo "Router started (pid $pid), logs: $START_LOG_FILE"
    else
        echo "Failed to start router; check $START_LOG_FILE"
        return 1
    fi
}

stop() {
    if [ ! -f "$START_PID_FILE" ]; then
        echo "Router does not appear to be running (no pidfile)."
        return 0
    fi
    pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
    if [ -z "$pid" ]; then
        echo "No pid in pidfile; removing."; rm -f "$START_PID_FILE"; return 0
    fi
    if kill -0 "$pid" 2>/dev/null; then
        kill "$pid" && echo "Sent SIGTERM to $pid" || echo "Failed to kill $pid"
        sleep 1
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" && echo "Sent SIGKILL to $pid"
        fi
    else
        echo "Process $pid not running; cleaning pidfile"
    fi
    rm -f "$START_PID_FILE"
}

status() {
    if [ -f "$START_PID_FILE" ]; then
        pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Router running (pid $pid)"
            # check health
            if command -v curl &>/dev/null; then
                if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
                    echo "Health check: OK"
                else
                    echo "Health check: not responding"
                fi
            fi
            return 0
        else
            echo "Stale pidfile found (pid $pid not running)"
            return 1
        fi
    else
        # fallback: try health endpoint
        if command -v curl &>/dev/null; then
            if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
                echo "Router responding on http://127.0.0.1:5555 (no pidfile)"
                return 0
            fi
        fi
        echo "Router not running"
        return 1
    fi
}

case "$1" in
    add) add $2 $3 ;;
    remove) remove $2 ;;
    list) list ;;
    url) url $2 ;;
    open) open_cmd $2 ;;
    validate) validate ;;
    edit) edit_config ;;
    resolve) resolve_mapping $2 ;;
    doctor) doctor ;;
    info|help|-h|--help) print_usage ;;
    export)
        if [[ "$2" == "caddy" ]]; then
            print_caddyfile
        else
            echo "Usage: devhost export caddy"
            exit 1
        fi
        ;;
    start) start ;;
    stop) stop ;;
    status) status ;;
    install)
        # support: devhost install --macos  OR devhost install macos
        if [[ "$2" == "--macos" || "$2" == "macos" ]]; then
            if [[ -x "scripts/setup-macos.sh" ]]; then
                bash scripts/setup-macos.sh "${@:3}"
            else
                bash ./scripts/setup-macos.sh "${@:3}"
            fi
        else
            echo "Usage: devhost install --macos"
            exit 1
        fi
        ;;
    *) print_usage;;
esac
