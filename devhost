#!/usr/bin/env bash

SCRIPT_PATH="${BASH_SOURCE[0]}"
if command -v readlink >/dev/null 2>&1; then
    SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH" 2>/dev/null || echo "$SCRIPT_PATH")"
fi
ROOT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
CONFIG="$ROOT_DIR/devhost.json"
CADDYFILE="$ROOT_DIR/caddy/Caddyfile"
DOMAIN_FILE="$ROOT_DIR/.devhost/domain"
PYTHON_BIN=""
if command -v python3 &> /dev/null; then
    PYTHON_BIN="python3"
elif command -v python &> /dev/null; then
    PYTHON_BIN="python"
fi

load_json() {
    if [[ ! -f "$CONFIG" ]]; then
        echo "{}" > "$CONFIG"
    fi
    cat "$CONFIG"
}

save_json() {
    echo "$1" > "$CONFIG"
}

first_mapping_name() {
    if command -v jq &> /dev/null; then
        jq -r 'keys[0] // empty' "$CONFIG"
    elif [ -n "$PYTHON_BIN" ]; then
        "$PYTHON_BIN" - "$CONFIG" <<'PY'
import json,sys
try:
    data=json.load(open(sys.argv[1]))
    keys=sorted(data.keys())
    print(keys[0] if keys else "")
except Exception:
    print("")
PY
    else
        echo ""
    fi
}

get_port_for_name() {
    name=$1
    if command -v jq &> /dev/null; then
        jq -r --arg k "$name" '.[$k] // empty' "$CONFIG"
    elif [ -n "$PYTHON_BIN" ]; then
        "$PYTHON_BIN" - "$CONFIG" "$name" <<'PY'
import json,sys
try:
    data=json.load(open(sys.argv[1]))
    print(data.get(sys.argv[2], ""))
except Exception:
    print("")
PY
    else
        echo ""
    fi
}



normalize_target() {
    value=$1
    scheme="http"
    host="127.0.0.1"
    port=""
    rest="$value"

    if [[ "$rest" =~ ^https?:// ]]; then
        scheme="${rest%%://*}"
        rest="${rest#*://}"
        rest="${rest%%/*}"
    fi

    if [[ "$rest" == *":"* ]]; then
        host="${rest%:*}"
        port="${rest##*:}"
    else
        port="$rest"
    fi

    if [ -z "$host" ] || [ -z "$port" ]; then
        echo ""
        return 1
    fi
    echo "${scheme} ${host} ${port}"
}

get_domain() {
    if [ -n "${DEVHOST_DOMAIN:-}" ]; then
        echo "$DEVHOST_DOMAIN" | tr -d ' \t\r\n'
        return 0
    fi
    if [ -f "$DOMAIN_FILE" ]; then
        tr -d ' \t\r\n' < "$DOMAIN_FILE"
        return 0
    fi
    echo "localhost"
}

set_domain() {
    new_domain=$1
    if [ -z "$new_domain" ]; then
        echo "Usage: devhost domain <base-domain>"
        return 1
    fi
    if echo "$new_domain" | grep -qE '^https?://|/'; then
        echo "Domain must be a host name only (no scheme or path)."
        return 1
    fi
    mkdir -p "$(dirname "$DOMAIN_FILE")"
    echo "$new_domain" > "$DOMAIN_FILE"
    echo "Domain set to $new_domain"
    generate_caddyfile
}

get_dev_scheme() {
    value=$1
    if [[ "$value" =~ ^https:// ]]; then
        echo "https"
    elif [[ "$value" =~ ^http:// ]]; then
        echo "http"
    else
        # default dev URL scheme
        echo "http"
    fi
}

open_in_browser() {
    url=$1
    if command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$url" >/dev/null 2>&1 &
    elif command -v open >/dev/null 2>&1; then
        open "$url" >/dev/null 2>&1 &
    elif command -v powershell.exe >/dev/null 2>&1; then
        powershell.exe -NoProfile -Command "Start-Process '$url'" >/dev/null 2>&1
    elif [ -n "$PYTHON_BIN" ]; then
        "$PYTHON_BIN" - <<PY >/dev/null 2>&1
import webbrowser
webbrowser.open("$url")
PY
    else
        echo "No supported browser opener found (xdg-open/open/powershell/python)."
        return 1
    fi
}

print_usage() {
    cat <<'EOF'
Usage: devhost <command> [args]

Commands:
  add <name> <port|host:port>          Add a mapping
  add <name> --http <port|host:port>   Force http for dev URL (default)
  add <name> --https <port|host:port>  Force https for dev URL
  remove <name>           Remove a mapping
  list                    List mappings
  list --json             List mappings as JSON
  url [name]              Print URL; press Ctrl+O to open (interactive)
  open [name]             Open URL in default browser
  validate                Quick config/router/DNS checks
  export caddy            Print generated Caddyfile
  edit                    Open devhost.json in $EDITOR (fallback: vi)
  resolve <name>          Show DNS resolution and port reachability
  doctor                  Deeper diagnostics (dnsmasq/systemd-resolved/Caddy)
  info                    Show this help
  domain [name]           Show or set base domain (default: localhost)
  start|stop|status       Manage router process
  install --macos [...]   Run macOS installer
  install --windows       Run Windows installer
EOF
}

edit_config() {
    editor="${EDITOR:-}"
    if [ -z "$editor" ]; then
        if command -v nano >/dev/null 2>&1; then
            editor="nano"
        elif command -v vi >/dev/null 2>&1; then
            editor="vi"
        else
            echo "No editor found. Set \$EDITOR or install nano/vi."
            return 1
        fi
    fi
    "$editor" "$CONFIG"
}

resolve_mapping() {
    name=$1
    if [ -z "$name" ]; then
        echo "Usage: devhost resolve <name>"
        return 1
    fi
    target=$(get_port_for_name "$name")
    base_domain=$(get_domain)
    if [ -z "$target" ]; then
        echo "No mapping found for ${name}.${base_domain}"
    else
        normalized=$(normalize_target "$target" || true)
        if [ -n "$normalized" ]; then
            scheme=$(echo "$normalized" | awk '{print $1}')
            host=$(echo "$normalized" | awk '{print $2}')
            port=$(echo "$normalized" | awk '{print $3}')
            echo "${name}.${base_domain} -> ${scheme}://${host}:${port}"
        else
            echo "${name}.${base_domain} -> ${target}"
        fi
    fi

    if command -v dig >/dev/null 2>&1; then
        ip=$(dig +short "${name}.${base_domain}" | head -n 1)
        if [ -n "$ip" ]; then
            echo "DNS: ${name}.${base_domain} -> ${ip}"
        else
            echo "DNS: unresolved"
        fi
    elif command -v getent >/dev/null 2>&1; then
        ip=$(getent hosts "${name}.${base_domain}" | awk '{print $1}' | head -n 1)
        if [ -n "$ip" ]; then
            echo "DNS: ${name}.${base_domain} -> ${ip}"
        else
            echo "DNS: unresolved"
        fi
    else
        echo "DNS: dig/getent not available"
    fi

    if [ -n "$target" ] && command -v nc >/dev/null 2>&1; then
        normalized=$(normalize_target "$target" || true)
        scheme=$(echo "$normalized" | awk '{print $1}')
        host=$(echo "$normalized" | awk '{print $2}')
        port=$(echo "$normalized" | awk '{print $3}')
        if nc -z "$host" "$port" >/dev/null 2>&1; then
            echo "Port: ${host}:${port} is open"
        else
            echo "Port: ${host}:${port} is not reachable"
        fi
    elif [ -n "$target" ]; then
        echo "Port: nc not available to test reachability"
    fi
}

doctor() {
    echo "Devhost doctor"
    echo "Root: $ROOT_DIR"
    echo "Config: $CONFIG"
    validate || true
    base_domain=$(get_domain)

    if [ "$base_domain" != "localhost" ]; then
        if command -v dig >/dev/null 2>&1; then
            if ! dig +short "hello.${base_domain}" | head -n 1 | grep -q '.'; then
                echo "DNS: ${base_domain} is not resolving locally."
                echo "Hint: add a hosts entry (e.g. 127.0.0.1 hello.${base_domain}) or configure a local DNS resolver."
            fi
        fi
    fi

    if command -v systemctl >/dev/null 2>&1; then
        if systemctl is-active --quiet caddy; then
            echo "Caddy: active"
        elif systemctl status caddy >/dev/null 2>&1; then
            echo "Caddy: installed but not active"
        else
            echo "Caddy: not found"
        fi

        if systemctl is-active --quiet dnsmasq; then
            echo "dnsmasq: active"
        elif systemctl status dnsmasq >/dev/null 2>&1; then
            echo "dnsmasq: installed but not active"
        else
            echo "dnsmasq: not found"
        fi

        if systemctl is-active --quiet systemd-resolved; then
            echo "systemd-resolved: active"
            if command -v resolvectl >/dev/null 2>&1; then
                resolvectl status 2>/dev/null | sed -n '1,60p'
            fi
        else
            echo "systemd-resolved: not active"
        fi
    else
        echo "systemctl not available; skipping service checks"
    fi
}


generate_caddyfile() {
    # generate project-local Caddyfile and a user-level Caddyfile if present
    domain=$(get_domain)
    echo "# Autogenerated Caddyfile" > "$CADDYFILE"
    echo "*.${domain} {" >> "$CADDYFILE"
    echo "    reverse_proxy localhost:5555" >> "$CADDYFILE"
    echo "    tls internal" >> "$CADDYFILE"
    echo "}" >> "$CADDYFILE"

    # Append explicit mappings from devhost.json
    json=$(load_json)
    if command -v jq &> /dev/null; then
        mapcount=$(echo "$json" | jq 'length')
        if [[ $mapcount -gt 0 ]]; then
            echo "" >> "$CADDYFILE"
            echo "# Direct mappings" >> "$CADDYFILE"
            echo "$json" | jq -r --arg d "$domain" 'to_entries[] | 
                (if (.value|tostring|test("^https://")) then .key+"."+$d else "http://"+.key+"."+$d end) as $site
                | $site + " {\n    reverse_proxy " + (if (.value|tostring|test("^https?://")) then (.value|tostring) elif (.value|tostring|test(":")) then (.value|tostring) else "127.0.0.1:" + (.value|tostring) end) + "\n" 
                + (if (.value|tostring|test("^https://")) then "    tls internal\n" else "" end)
                + "}\n"' >> "$CADDYFILE"
        fi
    else
        # fallback: use python to render mappings
        if [ -z "$PYTHON_BIN" ]; then
            echo "python3 (or python) is required to render mappings without jq."
            return 1
        fi
        "$PYTHON_BIN" - "$CONFIG" "$domain" <<PY >> "$CADDYFILE"
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
domain = sys.argv[2] if len(sys.argv) > 2 else "localhost"
for k,v in data.items():
    target = str(v)
    if target.startswith("https://"):
        print(f"{k}.{domain} {{")
    else:
        print(f"http://{k}.{domain} {{")
    target = str(v)
    if target.startswith("http://") or target.startswith("https://"):
        print(f"    reverse_proxy {target}")
    elif ":" in target:
        print(f"    reverse_proxy {target}")
    else:
        print(f"    reverse_proxy 127.0.0.1:{target}")
    if target.startswith("https://"):
        print("    tls internal")
    print("}")
PY
    fi

    # Also update user Caddyfile if present to support system-wide caddy configs
    USER_CADDY="$HOME/.config/caddy/Caddyfile"
    if [[ -d "$(dirname "$USER_CADDY")" ]]; then
        cp "$CADDYFILE" "$USER_CADDY"
    fi

    # Update system Caddyfile if present (requires sudo)
    SYSTEM_CADDY="/etc/caddy/Caddyfile"
    if [ -f "$SYSTEM_CADDY" ]; then
        if command -v sudo >/dev/null 2>&1; then
            sudo cp "$CADDYFILE" "$SYSTEM_CADDY" 2>/dev/null || true
        else
            echo "Note: /etc/caddy/Caddyfile exists but sudo is not available to update it."
        fi
    fi

    # reload caddy if systemctl is available
    if command -v systemctl &> /dev/null; then
        sudo systemctl reload caddy || true
    fi
}

print_caddyfile() {
    echo "# Autogenerated Caddyfile"
    domain=$(get_domain)
    echo "*.${domain} {"
    echo "    reverse_proxy localhost:5555"
    echo "    tls internal"
    echo "}"

    json=$(load_json)
    if command -v jq &> /dev/null; then
        mapcount=$(echo "$json" | jq 'length')
        if [[ $mapcount -gt 0 ]]; then
            echo ""
            echo "# Direct mappings"
            echo "$json" | jq -r --arg d "$domain" 'to_entries[] | 
                (if (.value|tostring|test("^https://")) then .key+"."+$d else "http://"+.key+"."+$d end) as $site
                | $site + " {\n    reverse_proxy " + (if (.value|tostring|test("^https?://")) then (.value|tostring) elif (.value|tostring|test(":")) then (.value|tostring) else "127.0.0.1:" + (.value|tostring) end) + "\n" 
                + (if (.value|tostring|test("^https://")) then "    tls internal\n" else "" end)
                + "}\n"'
        fi
    else
        if [ -z "$PYTHON_BIN" ]; then
            echo "python3 (or python) is required to render mappings without jq."
            return 1
        fi
        "$PYTHON_BIN" - "$CONFIG" "$domain" <<PY
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
domain = sys.argv[2] if len(sys.argv) > 2 else "localhost"
for k,v in data.items():
    target = str(v)
    if target.startswith("https://"):
        print(f"{k}.{domain} {{")
    else:
        print(f"http://{k}.{domain} {{")
    target = str(v)
    if target.startswith("http://") or target.startswith("https://"):
        print(f"    reverse_proxy {target}")
    elif ":" in target:
        print(f"    reverse_proxy {target}")
    else:
        print(f"    reverse_proxy 127.0.0.1:{target}")
    if target.startswith("https://"):
        print("    tls internal")
    print("}")
PY
    fi
}

add() {
    domain=$1
    shift
    scheme=""
    target=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --http) scheme="http"; shift ;;
            --https) scheme="https"; shift ;;
            *) target="$1"; shift ;;
        esac
    done

    if [ -z "$target" ]; then
        echo "Usage: devhost add <name> <port|host:port>"
        return 1
    fi

    if [ -n "$scheme" ]; then
        if [[ "$target" =~ ^https?:// ]]; then
            echo "Target already includes a scheme; do not combine with --http/--https"
            return 1
        fi
        if [[ "$target" =~ ^[0-9]+$ ]]; then
            target="127.0.0.1:${target}"
        fi
        target="${scheme}://${target}"
    fi

    json=$(load_json)
    # validate target
    if [[ "$target" =~ ^https?:// ]]; then
        stripped="${target#*://}"
        stripped="${stripped%%/*}"
        if [[ "$stripped" == *":"* ]]; then
            host_part="${stripped%:*}"
            port_part="${stripped##*:}"
            if [ -z "$host_part" ] || ! [[ $port_part =~ ^[0-9]+$ ]]; then
                echo "Port must be a number or host:port"
                return 1
            fi
        else
            if ! [[ "$stripped" =~ ^[0-9]+$ ]]; then
                echo "Port must be a number or host:port"
                return 1
            fi
        fi
    elif [[ "$target" == *":"* ]]; then
        host_part="${target%:*}"
        port_part="${target##*:}"
        if [ -z "$host_part" ] || ! [[ $port_part =~ ^[0-9]+$ ]]; then
            echo "Port must be a number or host:port"
            return 1
        fi
    else
        if ! [[ $target =~ ^[0-9]+$ ]]; then
            echo "Port must be a number or host:port"
            return 1
        fi
    fi
    if command -v jq &> /dev/null; then
        if [[ "$target" =~ ^https?:// ]]; then
            new_json=$(echo "$json" | jq --arg k "$domain" --arg p "$target" '. + {($k): $p}')
        elif [[ "$target" == *":"* ]]; then
            new_json=$(echo "$json" | jq --arg k "$domain" --arg p "$target" '. + {($k): $p}')
        else
            new_json=$(echo "$json" | jq --arg k "$domain" --arg p "$target" '. + {($k): ($p|tonumber)}')
        fi
    else
        if [ -z "$PYTHON_BIN" ]; then
            echo "python3 (or python) is required to add mappings without jq."
            return 1
        fi
        new_json=$("$PYTHON_BIN" - "$CONFIG" "$domain" "$target" <<PY
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
value=sys.argv[3]
try:
    value=int(value)
except Exception:
    pass
data[sys.argv[2]] = value
print(json.dumps(data))
PY
)
    fi
    save_json "$new_json"
    base_domain=$(get_domain)
    echo "[+] Mapped $domain.${base_domain} to $target"
    generate_caddyfile
}

remove() {
    domain=$1
    json=$(load_json)
    if command -v jq &> /dev/null; then
        new_json=$(echo "$json" | jq --arg k "$domain" 'del(.[$k])')
    else
        if [ -z "$PYTHON_BIN" ]; then
            echo "python3 (or python) is required to remove mappings without jq."
            return 1
        fi
        new_json=$("$PYTHON_BIN" - "$CONFIG" "$domain" <<PY
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
data.pop(sys.argv[2], None)
print(json.dumps(data))
PY
)
    fi
    save_json "$new_json"
    base_domain=$(get_domain)
    echo "[-] Removed mapping for $domain.${base_domain}"
    generate_caddyfile
}

list() {
    if [ "${1:-}" = "--json" ]; then
        if command -v jq &> /dev/null; then
            load_json | jq
        else
            if [ -z "$PYTHON_BIN" ]; then
                load_json
                return 0
            fi
            "$PYTHON_BIN" - "$CONFIG" <<PY
import json,sys
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
print(json.dumps(data, indent=2, sort_keys=True))
PY
        fi
        return 0
    fi

    json=$(load_json)
    domain=$(get_domain)
    if command -v jq &> /dev/null; then
        count=$(echo "$json" | jq 'length')
        if [ "$count" -eq 0 ]; then
            echo "No mappings yet. Add one with: devhost add <name> <port>"
            return 0
        fi
        echo "$json" | jq -r --arg d "$domain" '
            to_entries[] | 
            (.value|tostring) as $v |
            "\(.key)."+$d+" -> "+(if $v|test("^[0-9]+$") then "127.0.0.1:"+$v else $v end)
        '
    else
        if [ -z "$PYTHON_BIN" ]; then
            echo "No mappings yet. Add one with: devhost add <name> <port>"
            return 0
        fi
        "$PYTHON_BIN" - "$CONFIG" "$domain" <<PY
import json,sys
domain=sys.argv[2]
try:
    data=json.load(open(sys.argv[1]))
except Exception:
    data={}
if not data:
    print("No mappings yet. Add one with: devhost add <name> <port>")
else:
    for k,v in data.items():
        s=str(v)
        if s.isdigit():
            s=f"127.0.0.1:{s}"
        print(f"{k}.{domain} -> {s}")
PY
    fi
}

url() {
    name=$1
    if [ -z "$name" ]; then
        name=$(first_mapping_name)
        if [ -z "$name" ]; then
            echo "No mappings found. Add one with: devhost add <name> <port>"
            return 1
        fi
    fi
    target=$(get_port_for_name "$name")
    if [ -z "$target" ]; then
        base_domain=$(get_domain)
        echo "No mapping found for ${name}.${base_domain}"
        return 1
    fi
    base_domain=$(get_domain)
    scheme=$(get_dev_scheme "$target")
    echo "${scheme}://${name}.${base_domain}"
    # Optional: open when Ctrl+O is pressed (interactive only)
    if [ -t 0 ]; then
        read -r -n 1 -s -p "Press Ctrl+O to open in browser, any other key to skip... " key
        echo
        if [ "$key" = $'\x0f' ]; then
            open_in_browser "${scheme}://${name}.${base_domain}"
        fi
    fi
}

open_cmd() {
    name=$1
    if [ -z "$name" ]; then
        name=$(first_mapping_name)
        if [ -z "$name" ]; then
            echo "No mappings found. Add one with: devhost add <name> <port>"
            return 1
        fi
    fi
    target=$(get_port_for_name "$name")
    if [ -z "$target" ]; then
        base_domain=$(get_domain)
        echo "No mapping found for ${name}.${base_domain}"
        return 1
    fi
    base_domain=$(get_domain)
    scheme=$(get_dev_scheme "$target")
    open_in_browser "${scheme}://${name}.${base_domain}"
}

validate() {
    echo "Config: $CONFIG"
    if [ ! -f "$CONFIG" ]; then
        echo "Config file missing."
        return 1
    fi

    if command -v jq &> /dev/null; then
        if ! jq empty "$CONFIG" >/dev/null 2>&1; then
            echo "Config JSON: invalid"
            return 1
        fi
    elif [ -n "$PYTHON_BIN" ]; then
        if ! "$PYTHON_BIN" - "$CONFIG" <<'PY' >/dev/null 2>&1
import json,sys
json.load(open(sys.argv[1]))
PY
        then
            echo "Config JSON: invalid"
            return 1
        fi
    fi
    echo "Config JSON: OK"

    if command -v curl &>/dev/null; then
        if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
            echo "Router: OK"
        else
            echo "Router: not responding"
        fi
    else
        echo "Router: curl not available"
    fi

    name=$(first_mapping_name)
    base_domain=$(get_domain)
    if [ -n "$name" ]; then
        if command -v dig >/dev/null 2>&1; then
            if dig +short "${name}.${base_domain}" | grep -q '127.0.0.1'; then
                echo "DNS: OK (${name}.${base_domain} -> 127.0.0.1)"
            else
                echo "DNS: unresolved for ${name}.${base_domain}"
            fi
        elif command -v getent >/dev/null 2>&1; then
            if getent hosts "${name}.${base_domain}" | grep -q '127.0.0.1'; then
                echo "DNS: OK (${name}.${base_domain} -> 127.0.0.1)"
            else
                echo "DNS: unresolved for ${name}.${base_domain}"
            fi
        else
            echo "DNS: dig/getent not available"
        fi
    else
        echo "DNS: no mappings to test"
    fi
}

START_PID_FILE="$ROOT_DIR/.devhost/router.pid"
START_LOG_FILE="/tmp/devhost-router.log"

start() {
    # ensure router folder
    mkdir -p "$(dirname "$START_PID_FILE")"
    if [ -f "$START_PID_FILE" ]; then
        pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Router already running (pid $pid)"
            return 0
        else
            rm -f "$START_PID_FILE" || true
        fi
    fi

    # prefer using a python inside a venv if available
    VENV_PYTHON=""
    if [ -x "$ROOT_DIR/router/venv/bin/python" ]; then
        VENV_PYTHON="$ROOT_DIR/router/venv/bin/python"
    elif [ -x "$ROOT_DIR/router/venv/Scripts/python.exe" ]; then
        VENV_PYTHON="$ROOT_DIR/router/venv/Scripts/python.exe"
    elif [ -x "$ROOT_DIR/router/.venv/bin/python" ]; then
        VENV_PYTHON="$ROOT_DIR/router/.venv/bin/python"
    elif [ -x "$ROOT_DIR/router/.venv/Scripts/python.exe" ]; then
        VENV_PYTHON="$ROOT_DIR/router/.venv/Scripts/python.exe"
    elif [ -x "$ROOT_DIR/.venv/bin/python" ]; then
        VENV_PYTHON="$ROOT_DIR/.venv/bin/python"
    elif [ -x "$ROOT_DIR/.venv/Scripts/python.exe" ]; then
        VENV_PYTHON="$ROOT_DIR/.venv/Scripts/python.exe"
    fi

    if [ -n "$VENV_PYTHON" ]; then
        # normalize to absolute path to avoid relative path issues when cd'ing into router
        if command -v readlink >/dev/null 2>&1; then
            VENV_PYTHON_ABS=$(readlink -f "$VENV_PYTHON" 2>/dev/null || true)
        fi
        if [ -z "${VENV_PYTHON_ABS:-}" ]; then
            VENV_PYTHON_ABS="$(cd "$(dirname "$VENV_PYTHON")" 2>/dev/null && pwd)/$(basename "$VENV_PYTHON")"
        fi
        VENV_PYTHON="$VENV_PYTHON_ABS"
        echo "Using venv python: $VENV_PYTHON"
        # ensure uvicorn installed in venv
        if ! "$VENV_PYTHON" -c "import uvicorn" >/dev/null 2>&1; then
        if [ -f "$ROOT_DIR/router/requirements.txt" ]; then
            echo "uvicorn not found in venv; installing requirements into venv"
            "$VENV_PYTHON" -m pip install -r "$ROOT_DIR/router/requirements.txt" || true
        fi
        fi
        START_CMD=("$VENV_PYTHON" -m uvicorn app:app --host 127.0.0.1 --port 5555)
    else
        # fallback to uvicorn binary or system python
        if [ -x "$ROOT_DIR/.venv/bin/uvicorn" ]; then
            START_CMD=("$(cd "$(dirname "$ROOT_DIR/.venv/bin/uvicorn")" && pwd)/$(basename "$ROOT_DIR/.venv/bin/uvicorn")" "app:app" "--host" "127.0.0.1" "--port" "5555")
        elif [ -x "$ROOT_DIR/router/.venv/bin/uvicorn" ]; then
            START_CMD=("$(cd "$(dirname "$ROOT_DIR/router/.venv/bin/uvicorn")" && pwd)/$(basename "$ROOT_DIR/router/.venv/bin/uvicorn")" "app:app" "--host" "127.0.0.1" "--port" "5555")
        elif [ -x "$ROOT_DIR/router/venv/bin/uvicorn" ]; then
            START_CMD=("$(cd "$(dirname "$ROOT_DIR/router/venv/bin/uvicorn")" && pwd)/$(basename "$ROOT_DIR/router/venv/bin/uvicorn")" "app:app" "--host" "127.0.0.1" "--port" "5555")
        elif command -v uvicorn &>/dev/null; then
            START_CMD=("$(command -v uvicorn)" "app:app" "--host" "127.0.0.1" "--port" "5555")
        else
            START_CMD=("python3" -m uvicorn app:app --host 127.0.0.1 --port 5555)
        fi
    fi

    echo "Starting router with command: ${START_CMD[*]}"
    # start in router directory but manage pidfile from repo root
    pushd "$ROOT_DIR/router" >/dev/null 2>&1 || return 1
    nohup "${START_CMD[@]}" > "$START_LOG_FILE" 2>&1 &
    pid=$!
    popd >/dev/null 2>&1 || true
    echo "$pid" > "$START_PID_FILE" || { echo "Failed to write pidfile $START_PID_FILE"; return 1; }
    sleep 1
    if kill -0 "$pid" 2>/dev/null; then
        echo "Router started (pid $pid), logs: $START_LOG_FILE"
    else
        echo "Failed to start router; check $START_LOG_FILE"
        return 1
    fi
}

stop() {
    if [ ! -f "$START_PID_FILE" ]; then
        echo "Router does not appear to be running (no pidfile)."
        return 0
    fi
    pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
    if [ -z "$pid" ]; then
        echo "No pid in pidfile; removing."; rm -f "$START_PID_FILE"; return 0
    fi
    if kill -0 "$pid" 2>/dev/null; then
        kill "$pid" && echo "Sent SIGTERM to $pid" || echo "Failed to kill $pid"
        sleep 1
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" && echo "Sent SIGKILL to $pid"
        fi
    else
        echo "Process $pid not running; cleaning pidfile"
    fi
    rm -f "$START_PID_FILE"
}

status() {
    if [ "${1:-}" = "--json" ]; then
        running=false
        pid=""
        health="unknown"
        if [ -f "$START_PID_FILE" ]; then
            pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                running=true
            fi
        else
            if command -v curl &>/dev/null; then
                if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
                    running=true
                fi
            fi
        fi
        if command -v curl &>/dev/null; then
            if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
                health="ok"
            else
                health="not_responding"
            fi
        fi
        printf '{"running":%s,"pid":%s,"health":"%s"}\n' \
            "$running" \
            "$( [ -n "$pid" ] && echo "$pid" || echo null )" \
            "$health"
        return 0
    fi
    if [ -f "$START_PID_FILE" ]; then
        pid=$(cat "$START_PID_FILE" 2>/dev/null || true)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Router running (pid $pid)"
            # check health
            if command -v curl &>/dev/null; then
                if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
                    echo "Health check: OK"
                else
                    echo "Health check: not responding"
                fi
            fi
            return 0
        else
            echo "Stale pidfile found (pid $pid not running)"
            return 1
        fi
    else
        # fallback: try health endpoint
        if command -v curl &>/dev/null; then
            if curl -sS --max-time 2 http://127.0.0.1:5555/health >/dev/null 2>&1; then
                echo "Router responding on http://127.0.0.1:5555 (no pidfile)"
                return 0
            fi
        fi
        echo "Router not running"
        return 1
    fi
}

case "$1" in
    add) add "${@:2}" ;;
    remove) remove $2 ;;
    list) list "${@:2}" ;;
    url) url $2 ;;
    open) open_cmd $2 ;;
    validate) validate ;;
    edit) edit_config ;;
    resolve) resolve_mapping $2 ;;
    doctor) doctor ;;
    domain)
        if [ -n "${2:-}" ]; then
            set_domain "$2"
        else
            get_domain
        fi
        ;;
    info|help|-h|--help) print_usage ;;
    export)
        if [[ "$2" == "caddy" ]]; then
            print_caddyfile
        else
            echo "Usage: devhost export caddy"
            exit 1
        fi
        ;;
    start) start ;;
    stop) stop ;;
    status) status "$2" ;;
    install)
        # support: devhost install --macos | --windows
        if [[ "$2" == "--macos" || "$2" == "macos" ]]; then
            if [[ -x "scripts/setup-macos.sh" ]]; then
                bash scripts/setup-macos.sh "${@:3}"
            else
                bash ./scripts/setup-macos.sh "${@:3}"
            fi
        elif [[ "$2" == "--windows" || "$2" == "windows" ]]; then
            if command -v powershell.exe >/dev/null 2>&1; then
                powershell.exe -NoProfile -ExecutionPolicy Bypass -File "$ROOT_DIR/scripts/setup-windows.ps1"
            else
                echo "powershell.exe not found; run scripts/setup-windows.ps1 from Windows PowerShell."
                exit 1
            fi
        else
            echo "Usage: devhost install --macos | --windows"
            exit 1
        fi
        ;;
    *) print_usage;;
esac
